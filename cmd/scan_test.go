package cmd

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/verity-org/verity/internal"
)

func TestImageKey(t *testing.T) {
	tests := []struct {
		name string
		img  internal.Image
		want string
	}{
		{
			name: "simple repository",
			img:  internal.Image{Repository: "nginx"},
			want: "nginx",
		},
		{
			name: "repository with slash",
			img:  internal.Image{Repository: "prometheus/prometheus"},
			want: "prometheus-prometheus",
		},
		{
			name: "repository with multiple slashes",
			img:  internal.Image{Repository: "gcr.io/google-containers/pause"},
			want: "gcr.io-google-containers-pause",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := imageKey(tt.img)
			if got != tt.want {
				t.Errorf("imageKey() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestWriteImagesToValues(t *testing.T) {
	tests := []struct {
		name    string
		images  []internal.Image
		wantErr bool
		checks  []string // substrings that must appear in output
	}{
		{
			name: "single image with all fields",
			images: []internal.Image{
				{
					Registry:   "quay.io",
					Repository: "prometheus/prometheus",
					Tag:        "v2.45.0",
					Path:       "server.image",
				},
			},
			checks: []string{
				"prometheus-prometheus:",
				"registry: quay.io",
				"repository: prometheus/prometheus",
				`tag: "v2.45.0"`,
				"# from: server.image",
			},
		},
		{
			name: "image without registry",
			images: []internal.Image{
				{
					Repository: "nginx",
					Tag:        "1.25",
					Path:       "web.image",
				},
			},
			checks: []string{
				"nginx:",
				"repository: nginx",
				`tag: "1.25"`,
				"# from: web.image",
			},
		},
		{
			name: "image without tag",
			images: []internal.Image{
				{
					Registry:   "docker.io",
					Repository: "library/alpine",
					Path:       "base.image",
				},
			},
			checks: []string{
				"library-alpine:",
				"registry: docker.io",
				"repository: library/alpine",
				"# from: base.image",
			},
		},
		{
			name: "multiple images with key collisions",
			images: []internal.Image{
				{
					Registry:   "quay.io",
					Repository: "prometheus/prometheus",
					Tag:        "v2.45.0",
				},
				{
					Registry:   "docker.io",
					Repository: "prometheus/prometheus",
					Tag:        "v2.46.0",
				},
			},
			checks: []string{
				"prometheus-prometheus:",
				"prometheus-prometheus-docker-io:",
				"registry: quay.io",
				"registry: docker.io",
			},
		},
		{
			name: "header comments",
			images: []internal.Image{
				{Repository: "nginx", Tag: "latest"},
			},
			checks: []string{
				"# Container images discovered from Helm chart",
				"# Generated by verity scan",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpDir := t.TempDir()
			outputPath := filepath.Join(tmpDir, "values.yaml")

			err := writeImagesToValues(tt.images, outputPath)
			if (err != nil) != tt.wantErr {
				t.Errorf("writeImagesToValues() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if tt.wantErr {
				return
			}

			// Read the output file
			content, err := os.ReadFile(outputPath)
			if err != nil {
				t.Fatalf("failed to read output file: %v", err)
			}

			output := string(content)

			// Check for expected substrings
			for _, check := range tt.checks {
				if !strings.Contains(output, check) {
					t.Errorf("output missing expected substring %q\nGot:\n%s", check, output)
				}
			}
		})
	}
}

func TestWriteImagesToValues_EmptyList(t *testing.T) {
	tmpDir := t.TempDir()
	outputPath := filepath.Join(tmpDir, "values.yaml")

	err := writeImagesToValues([]internal.Image{}, outputPath)
	if err != nil {
		t.Errorf("writeImagesToValues() with empty list should not error, got: %v", err)
	}

	// Should still create the file with just headers
	content, err := os.ReadFile(outputPath)
	if err != nil {
		t.Fatalf("failed to read output file: %v", err)
	}

	output := string(content)
	if !strings.Contains(output, "# Container images discovered from Helm chart") {
		t.Errorf("output should contain header even with empty list")
	}
}

func TestWriteImagesToValues_KeyCollisionHandling(t *testing.T) {
	// Test that we properly handle multiple images with the same repository
	// but different registries
	images := []internal.Image{
		{
			Registry:   "quay.io",
			Repository: "prometheus/prometheus",
			Tag:        "v1",
		},
		{
			Registry:   "docker.io",
			Repository: "prometheus/prometheus",
			Tag:        "v2",
		},
		{
			Registry:   "gcr.io",
			Repository: "prometheus/prometheus",
			Tag:        "v3",
		},
	}

	tmpDir := t.TempDir()
	outputPath := filepath.Join(tmpDir, "values.yaml")

	err := writeImagesToValues(images, outputPath)
	if err != nil {
		t.Fatalf("writeImagesToValues() error = %v", err)
	}

	content, err := os.ReadFile(outputPath)
	if err != nil {
		t.Fatalf("failed to read output file: %v", err)
	}

	output := string(content)

	// Should have three different keys
	expectedKeys := []string{
		"prometheus-prometheus:",
		"prometheus-prometheus-docker-io:",
		"prometheus-prometheus-gcr-io:",
	}

	for _, key := range expectedKeys {
		if !strings.Contains(output, key) {
			t.Errorf("output missing expected key %q\nGot:\n%s", key, output)
		}
	}

	// Each tag should appear exactly once
	for _, img := range images {
		tag := `tag: "` + img.Tag + `"`
		count := strings.Count(output, tag)
		if count != 1 {
			t.Errorf("expected tag %q to appear once, got %d times", tag, count)
		}
	}
}

func TestExtractOverrides(t *testing.T) {
	tests := []struct {
		name    string
		content string
		want    string
	}{
		{
			name: "no overrides section",
			content: `# Container images discovered from Helm chart
# Generated by verity scan

grafana-grafana:
  image:
    registry: docker.io
    repository: grafana/grafana
`,
			want: "",
		},
		{
			name: "with overrides section",
			content: `# Container images discovered from Helm chart
# Generated by verity scan

overrides:
  timberio/vector:
    from: "distroless-libc"
    to: "debian"

grafana-grafana:
  image:
    registry: docker.io
`,
			want: `# Image tag overrides for Copa-incompatible variants.
# Copa cannot patch distroless, Alpine, or scratch images.
# Use overrides to swap unpatchable variants with Copa-compatible ones.
overrides:
  timberio/vector:
    from: "distroless-libc"
    to: "debian"
`,
		},
		{
			name: "with multiple overrides",
			content: `# Container images discovered from Helm chart

overrides:
  timberio/vector:
    from: "distroless-libc"
    to: "debian"
  nginx:
    from: "alpine"
    to: "debian"

grafana-grafana:
  image:
    registry: docker.io
`,
			want: `# Image tag overrides for Copa-incompatible variants.
# Copa cannot patch distroless, Alpine, or scratch images.
# Use overrides to swap unpatchable variants with Copa-compatible ones.
overrides:
  timberio/vector:
    from: "distroless-libc"
    to: "debian"
  nginx:
    from: "alpine"
    to: "debian"
`,
		},
		{
			name:    "nonexistent file",
			content: "",
			want:    "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var path string
			if tt.content != "" {
				tmpDir := t.TempDir()
				path = filepath.Join(tmpDir, "values.yaml")
				if err := os.WriteFile(path, []byte(tt.content), 0o644); err != nil {
					t.Fatalf("failed to create test file: %v", err)
				}
			} else {
				// Test with nonexistent file path
				path = filepath.Join(t.TempDir(), "nonexistent.yaml")
			}

			got := extractOverrides(path)
			if got != tt.want {
				t.Errorf("extractOverrides() =\n%q\n\nwant:\n%q", got, tt.want)
			}
		})
	}
}

func TestWriteImagesToValues_PreservesOverrides(t *testing.T) {
	// Create a values.yaml with overrides
	tmpDir := t.TempDir()
	valuesPath := filepath.Join(tmpDir, "values.yaml")

	initialContent := `# Container images discovered from Helm chart
# Generated by verity scan

overrides:
  timberio/vector:
    from: "distroless-libc"
    to: "debian"

old-image:
  image:
    registry: docker.io
    repository: old/image
    tag: "1.0"
`

	if err := os.WriteFile(valuesPath, []byte(initialContent), 0o644); err != nil {
		t.Fatalf("failed to create initial values.yaml: %v", err)
	}

	// Now regenerate with new images
	newImages := []internal.Image{
		{
			Registry:   "quay.io",
			Repository: "prometheus/prometheus",
			Tag:        "v2.45.0",
		},
	}

	err := writeImagesToValues(newImages, valuesPath)
	if err != nil {
		t.Fatalf("writeImagesToValues() error = %v", err)
	}

	content, err := os.ReadFile(valuesPath)
	if err != nil {
		t.Fatalf("failed to read regenerated file: %v", err)
	}

	output := string(content)

	// Verify overrides are preserved
	if !strings.Contains(output, "overrides:") {
		t.Errorf("overrides section not preserved")
	}
	if !strings.Contains(output, "timberio/vector:") {
		t.Errorf("override entry not preserved")
	}
	if !strings.Contains(output, `from: "distroless-libc"`) {
		t.Errorf("override value not preserved")
	}

	// Verify new images are present
	if !strings.Contains(output, "prometheus-prometheus:") {
		t.Errorf("new image not written")
	}

	// Verify old images are gone
	if strings.Contains(output, "old-image:") {
		t.Errorf("old images should be replaced")
	}

	// Verify order: overrides should come before images
	overridesIdx := strings.Index(output, "overrides:")
	imagesIdx := strings.Index(output, "prometheus-prometheus:")
	if overridesIdx == -1 || imagesIdx == -1 || overridesIdx >= imagesIdx {
		t.Errorf("overrides should appear before images in output")
	}
}
