package cmd

import (
	"bufio"
	"errors"
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/urfave/cli/v2"

	"github.com/verity-org/verity/internal"
)

var errNoImagesFound = errors.New("no images found in chart")

// ScanCommand scans a Helm chart for container images and exports them to values.yaml.
var ScanCommand = &cli.Command{
	Name:  "scan",
	Usage: "Scan a Helm chart for container images and export to values.yaml",
	Flags: []cli.Flag{
		&cli.StringFlag{
			Name:     "chart",
			Aliases:  []string{"c"},
			Usage:    "path to Helm chart directory",
			Required: true,
		},
		&cli.StringFlag{
			Name:    "output",
			Aliases: []string{"o"},
			Value:   "values.yaml",
			Usage:   "output path for values.yaml",
		},
	},
	Action: runScan,
}

func runScan(c *cli.Context) error {
	chartPath := c.String("chart")
	outputPath := c.String("output")

	// Scan the chart for images
	images, err := internal.ScanForImages(chartPath)
	if err != nil {
		return fmt.Errorf("scanning chart: %w", err)
	}

	if len(images) == 0 {
		return errNoImagesFound
	}

	// Sort for deterministic output
	sort.Slice(images, func(i, j int) bool {
		return images[i].Reference() < images[j].Reference()
	})

	// Write to values.yaml
	if err := writeImagesToValues(images, outputPath); err != nil {
		return fmt.Errorf("writing values: %w", err)
	}

	fmt.Printf("Found %d images in %s\n", len(images), chartPath)
	fmt.Printf("Wrote images to %s\n", outputPath)

	return nil
}

func writeImagesToValues(images []internal.Image, path string) error {
	usedKeys := make(map[string]bool)
	var sb strings.Builder

	sb.WriteString("# Container images discovered from Helm chart\n")
	sb.WriteString("# Generated by verity scan\n\n")

	// Preserve existing overrides section if present
	if overrides := extractOverrides(path); overrides != "" {
		sb.WriteString(overrides)
		sb.WriteString("\n")
	}

	for _, img := range images {
		// Generate a unique key for this image
		baseKey := imageKey(img)
		key := baseKey

		// Handle key collisions
		if usedKeys[key] {
			disambiguator := strings.ReplaceAll(img.Registry, ".", "-")
			if disambiguator == "" {
				disambiguator = "image"
			}
			candidate := fmt.Sprintf("%s-%s", baseKey, disambiguator)
			i := 1
			for usedKeys[candidate] {
				candidate = fmt.Sprintf("%s-%s-%d", baseKey, disambiguator, i)
				i++
			}
			key = candidate
		}
		usedKeys[key] = true

		// Write the image entry
		sb.WriteString(key + ":\n")
		sb.WriteString("  image:\n")
		if img.Registry != "" {
			sb.WriteString(fmt.Sprintf("    registry: %s\n", img.Registry))
		}
		sb.WriteString(fmt.Sprintf("    repository: %s\n", img.Repository))
		if img.Tag != "" {
			sb.WriteString(fmt.Sprintf("    tag: %q\n", img.Tag))
		}
		if img.Path != "" {
			sb.WriteString(fmt.Sprintf("    # from: %s\n", img.Path))
		}
	}

	return os.WriteFile(path, []byte(sb.String()), 0o644)
}

// imageKey generates a YAML key from an image repository
// e.g. "prometheus/prometheus" â†’ "prometheus-prometheus".
func imageKey(img internal.Image) string {
	return strings.ReplaceAll(img.Repository, "/", "-")
}

// extractOverrides reads the existing values.yaml and extracts the overrides section
// Returns the overrides section as a string, or empty string if not found.
func extractOverrides(path string) string {
	file, err := os.Open(path)
	if err != nil {
		// File doesn't exist or can't be read - no overrides to preserve
		return ""
	}
	defer func() { _ = file.Close() }()

	var overridesLines []string
	var inOverrides bool
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()

		// Start of overrides section
		if strings.HasPrefix(line, "overrides:") {
			inOverrides = true
			overridesLines = append(overridesLines, line)
			continue
		}

		// If we're in overrides section
		if inOverrides {
			// End of overrides: non-indented line that's not a comment
			if line != "" && !strings.HasPrefix(line, " ") && !strings.HasPrefix(line, "#") {
				break
			}
			overridesLines = append(overridesLines, line)
		}
	}

	if len(overridesLines) == 0 {
		return ""
	}

	// Add comment explaining the section
	result := "# Image tag overrides for Copa-incompatible variants.\n"
	result += "# Copa cannot patch distroless, Alpine, or scratch images.\n"
	result += "# Use overrides to swap unpatchable variants with Copa-compatible ones.\n"
	result += strings.Join(overridesLines, "\n")

	return result
}
