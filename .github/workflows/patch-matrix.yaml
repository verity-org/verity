name: Patch Images (Matrix)

# Matrix-based patching workflow for parallel execution:
# 1. Mirror BuildKit: Copy buildkit image to GHCR (avoids flaky mirror.gcr.io pulls)
# 2. Scan: Generate fresh Trivy reports (OS + library vulns) using Trivy server
# 3. Discover: Copa dry-run with skip detection to find what needs patching
# 4. Patch: Parallel matrix jobs patch individual images per platform (native builds)
#           Includes app-level patching (--pkg-types os,library, COPA_EXPERIMENTAL=1)
# 5. Combine: Create multi-platform manifest lists
# 6. Attest: Attach CycloneDX SBOM attestations via actions/attest-sbom
# 7. Post-Scan: Scan patched images to capture remaining vulnerabilities
# 8. Assemble: Collect results and generate before/after catalog
# 9. Deploy: Publish site to GitHub Pages

on:
  schedule:
    - cron: '0 2 * * *'
  push:
    branches: [main]
    paths: ['copa-config.yaml', '.github/workflows/patch-matrix.yaml']
  pull_request:
    paths: ['copa-config.yaml', '.github/workflows/patch-matrix.yaml', 'internal/**', 'cmd/**']
  workflow_dispatch:

permissions:
  contents: write
  packages: write
  id-token: write

env:
  # Target registry for final patched images
  TARGET_REGISTRY: ghcr.io/verity-org
  # GHCR staging registry for intermediate platform-specific images
  STAGING_REGISTRY: ghcr.io/verity-org/cache
  # BuildKit image mirrored to GHCR to avoid flaky pulls from mirror.gcr.io
  BUILDKIT_IMAGE: ghcr.io/verity-org/cache/buildkit:buildx-stable-1
  # Platforms to build: always test both amd64 + arm64 (even in PRs) to catch platform-specific issues early
  PLATFORMS: linux/amd64,linux/arm64

jobs:
  # ── Job 1: Mirror BuildKit image to GHCR ───────────────────────────
  mirror-buildkit:
    name: Mirror BuildKit
    runs-on: ubuntu-24.04
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@a90bcbc6539c36a85cdfeb73f7e2f433735f215b # v2.15.0
        with:
          egress-policy: audit

      - uses: imjasonh/setup-crane@31b88efe9de28ae0ffa220711af4b60be9435f6e # v0.4

      - name: Login to GHCR
        uses: step-security/docker-login-action@c3e677aae8393bc9c81cfdf9709648720ea4bd4d # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Mirror BuildKit to GHCR
        # crane copy is idempotent: skips blobs already in GHCR, so no digest check needed.
        # Fallback: if upstream is unreachable, succeed if the mirror already exists in GHCR.
        run: |
          crane copy mirror.gcr.io/moby/buildkit:buildx-stable-1 "${BUILDKIT_IMAGE}" \
            || crane digest "${BUILDKIT_IMAGE}" > /dev/null \
            || { echo "Error: no BuildKit available (upstream down, no GHCR mirror)"; exit 1; }

  # ── Job 2: Scan images and discover what needs patching ────────────
  scan:
    name: Scan & Discover
    runs-on: ubuntu-24.04
    outputs:
      matrix: ${{ steps.discover.outputs.matrix }}
      has_images: ${{ steps.discover.outputs.has_images }}
      has_catalog_images: ${{ steps.discover.outputs.has_catalog_images }}

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@a90bcbc6539c36a85cdfeb73f7e2f433735f215b # v2.15.0
        with:
          egress-policy: audit

      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff # v5.6.0
        with:
          go-version-file: go.mod

      - name: Login to GHCR
        uses: step-security/docker-login-action@c3e677aae8393bc9c81cfdf9709648720ea4bd4d # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup binaries
        uses: ./.github/actions/setup-binaries
        with:
          github-token: ${{ github.token }}

      - name: Setup Trivy
        uses: step-security/setup-trivy@c90a9e4ee674152fc961ef98d44fc670a5dcceb7 # v0.2.5
        with:
          version: v0.68.2
          cache: true

      - name: Cache Trivy database
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/.cache/trivy
          key: trivy-db-${{ github.run_id }}
          restore-keys: |
            trivy-db-

      - name: Start Trivy server
        run: |
          trivy server --listen 0.0.0.0:4954 &
          timeout 60 bash -c 'until curl -f http://localhost:4954/healthz 2>/dev/null; do sleep 1; done'
          echo "✓ Trivy server ready"

      - name: Scan all images with Trivy
        run: |
          # Scan both source and patched images to detect if re-patching is needed
          # Copa's skip detection checks existing patched images for new vulnerabilities
          ./verity scan \
            --config copa-config.yaml \
            --target-registry "$TARGET_REGISTRY" \
            --trivy-server http://localhost:4954 \
            --parallel 10 \
            --output reports/

      - name: Run Copa dry-run discovery
        id: discover
        run: .github/scripts/copa-discover.sh copa-config.yaml reports/

      - name: Scan chart-discovered images
        run: |
          # verity scan only processes the images: section; chart-discovered images need separate scanning.
          # For each WouldPatch image in Copa's results, scan it if a report file is missing.
          jq -r '.[] | select(.status == "WouldPatch") | .source' results.json | \
          while IFS= read -r source; do
            report="reports/$(echo "$source" | sed 's/[\/:]/_/g').json"
            if [ ! -f "$report" ]; then
              echo "Scanning chart image: $source"
              if trivy image \
                --server http://localhost:4954 \
                --vuln-type os,library \
                --format json \
                --quiet \
                "$source" > "$report"; then
                echo "✓ Scanned: $source"
              else
                echo "⚠️  Failed to scan $source, creating empty report"
                echo "{\"ArtifactName\": \"$source\", \"Results\": []}" > "$report"
              fi
            fi
          done

      - name: Upload scan and discovery results
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: scan-results
          path: |
            reports/
            results.json
            matrix.json
          retention-days: 30

  # ── Job 2: Patch images in parallel per platform ───────────────────
  patch:
    name: "Patch ${{ matrix.name }}"
    needs: [scan, mirror-buildkit]
    if: needs.scan.outputs.has_images == 'true'
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix: ${{ fromJson(needs.scan.outputs.matrix) }}
      fail-fast: false
      max-parallel: 10

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@a90bcbc6539c36a85cdfeb73f7e2f433735f215b # v2.15.0
        with:
          egress-policy: audit

      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff # v5.6.0
        with:
          go-version-file: go.mod

      - name: Login to GHCR
        uses: step-security/docker-login-action@c3e677aae8393bc9c81cfdf9709648720ea4bd4d # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - uses: imjasonh/setup-crane@31b88efe9de28ae0ffa220711af4b60be9435f6e # v0.4

      - name: Setup BuildKit
        id: buildx-setup
        run: |
          # Create buildx builder (will inherit credentials from docker login)
          docker buildx create \
            --name copa-builder \
            --driver docker-container \
            --driver-opt network=host \
            --driver-opt "image=${BUILDKIT_IMAGE}" \
            --buildkitd-flags '--allow-insecure-entitlement network.host' \
            --use

          docker buildx inspect --bootstrap

      - name: Download scan results
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: scan-results
          path: .

      - name: Setup binaries
        uses: ./.github/actions/setup-binaries
        with:
          github-token: ${{ github.token }}

      - name: Patch image
        env:
          COPA_EXPERIMENTAL: "1"
        run: |
          # Extract platform arch for tag suffix (linux/amd64 -> amd64)
          PLATFORM_ARCH=$(echo "${{ matrix.platform }}" | cut -d/ -f2)

          # Extract source tag (e.g., nginx:1.29.4 -> 1.29.4)
          SOURCE_TAG=$(echo "${{ matrix.source }}" | cut -d: -f2)

          # GHCR staging is a single repo with mutable tags
          # Tag format: <image-name>-<version>-patched-<arch>
          # Sanitize image name: chart images contain registry paths with slashes (invalid in OCI tags)
          SAFE_IMAGE=$(echo "${{ matrix.image }}" | tr '/: ' '---')
          PLATFORM_TAG="${STAGING_REGISTRY}:${SAFE_IMAGE}-${SOURCE_TAG}-patched-${PLATFORM_ARCH}"

          # Construct report filename (match how scan.go creates them)
          REPORT_FILE="reports/$(echo '${{ matrix.source }}' | sed 's/[\/:]/_/g').json"

          echo "Using report file: $REPORT_FILE"

          # Copa will patch the native platform of this runner (amd64 or arm64)
          # BuildKit configured with GHCR credentials to push
          # --pkg-types os,library patches both OS packages and app-level deps (pip, npm)
          # --library-patch-level minor allows minor version bumps for library fixes
          copa patch \
            --image "${{ matrix.source }}" \
            --tag "$PLATFORM_TAG" \
            --report "$REPORT_FILE" \
            --pkg-types os,library \
            --library-patch-level minor \
            --push \
            --addr buildx://copa-builder \
            --timeout 30m

          # When Copa finds no OS package updates it exits 0 but does not push.
          # Copy the source image to the staging tag so the combine step can build
          # the multi-platform manifest regardless of whether patches were applied.
          crane digest "$PLATFORM_TAG" > /dev/null 2>&1 \
            || crane copy --platform "${{ matrix.platform }}" "${{ matrix.source }}" "$PLATFORM_TAG"

          echo "Patched platform-specific image: $PLATFORM_TAG"

      - name: Generate patch report
        if: always()
        run: |
          mkdir -p patch-results
          echo '{"name": "${{ matrix.name }}", "image": "${{ matrix.image }}", "source": "${{ matrix.source }}", "target": "${{ matrix.target }}", "platform": "${{ matrix.platform }}", "status": "patched"}' \
            > patch-results/${{ matrix.name }}.json

      - name: Upload patch result
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: patch-result-${{ matrix.name }}
          path: patch-results/
          retention-days: 7

  # ── Job 3: Combine platform images into manifest lists ─────────────
  combine:
    name: Create Manifest Lists
    needs: [scan, patch]
    if: needs.scan.outputs.has_images == 'true' && needs.patch.result == 'success'
    runs-on: ubuntu-24.04
    outputs:
      has_manifests: ${{ steps.attestation-matrix.outputs.has_manifests }}
      attestation_matrix: ${{ steps.attestation-matrix.outputs.attestation_matrix }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@a90bcbc6539c36a85cdfeb73f7e2f433735f215b # v2.15.0
        with:
          egress-policy: audit

      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Login to GHCR
        uses: step-security/docker-login-action@c3e677aae8393bc9c81cfdf9709648720ea4bd4d # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - uses: imjasonh/setup-crane@31b88efe9de28ae0ffa220711af4b60be9435f6e # v0.4

      - name: Install cosign
        if: github.event_name != 'pull_request'
        uses: step-security/cosign-installer@9610e5af306c47db1756d9e09a0388449e336ab7 # v4.0.0

      - name: Download patch results
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          pattern: patch-result-*
          path: patch-results/
          merge-multiple: true

      - name: Create manifest lists
        run: |
          # Collect all patched images
          cat patch-results/*.json | jq -s '.' > all-patches.json

          # Get unique image:tag combinations (group by image name and source tag)
          IMAGES=$(jq -r '.[] | .image + ":" + (.source | split(":")[1])' all-patches.json | sort -u)

          for IMAGE_TAG in $IMAGES; do
            IMAGE=$(echo "$IMAGE_TAG" | cut -d: -f1)
            TAG=$(echo "$IMAGE_TAG" | cut -d: -f2-)

            echo "Creating manifest list for $IMAGE:$TAG..."

            # Build list of platform-specific source tags from GHCR staging
            # Staging registry uses a single repo with mutable tags
            # Sanitize image name to match how PLATFORM_TAG was constructed (slashes → dashes)
            SOURCE_TAGS=$(jq -r --arg img "$IMAGE" --arg tag "$TAG" \
              'map(select(.image == $img and (.source | split(":")[1]) == $tag)) |
               .[] |
               (.platform | split("/")[1]) as $arch |
               ($img | gsub("[/: ]"; "-")) as $safe_img |
               "'"${STAGING_REGISTRY}"':" + $safe_img + "-" + $tag + "-patched-" + $arch' \
              all-patches.json)

            # Verify all platform images exist before creating manifest
            ALL_EXIST=true
            for source_tag in $SOURCE_TAGS; do
              if ! crane digest "$source_tag" > /dev/null 2>&1; then
                echo "⚠️  Skipping $IMAGE:$TAG - missing platform image: $source_tag"
                ALL_EXIST=false
                break
              fi
            done

            if [ "$ALL_EXIST" = "false" ]; then
              continue
            fi

            # Use Copa's computed target tag (may include a version suffix, e.g. 2.5.0-patched-1)
            COPA_TARGET=$(jq -r --arg img "$IMAGE" --arg tag "$TAG" \
              'map(select(.image == $img and (.source | split(":")[1]) == $tag)) | first | .target' \
              all-patches.json)

            if [ -z "$COPA_TARGET" ] || [ "$COPA_TARGET" = "null" ]; then
              echo "⚠️  Skipping $IMAGE:$TAG - no target manifest tag found in all-patches.json"
              continue
            fi

            # In production: push to target registry using Copa's computed tag
            # In PRs: rewrite to staging registry so we don't pollute production
            if [ "${{ github.event_name }}" != "pull_request" ]; then
              MANIFEST_TAG="$COPA_TARGET"
            else
              # Replace ':' in tag so it's OCI-valid (e.g. k8s-sidecar:2.3.0-patched-1 → k8s-sidecar-2.3.0-patched-1)
              STAGING_TAG="${COPA_TARGET##*/}"
              MANIFEST_TAG="${STAGING_REGISTRY}:${STAGING_TAG//:/-}"
            fi

            # imagetools copies platform images and creates the manifest list in one step
            # shellcheck disable=SC2086
            docker buildx imagetools create --tag "$MANIFEST_TAG" $SOURCE_TAGS
            echo "✓ Created manifest: $MANIFEST_TAG"
            echo "$MANIFEST_TAG" >> ghcr-manifests.txt
          done

      - name: Sign GHCR images
        if: github.event_name != 'pull_request'
        run: |
          if [ ! -f ghcr-manifests.txt ]; then
            echo "No manifests to sign"
            exit 0
          fi

          while IFS= read -r manifest; do
            cosign sign --yes "$manifest"
            echo "✓ Signed: $manifest"
          done < ghcr-manifests.txt

      - name: Build attestation matrix
        id: attestation-matrix
        run: |
          MATRIX_ITEMS="[]"
          if [ -f ghcr-manifests.txt ]; then
            while IFS= read -r manifest; do
              DIGEST=$(crane digest "$manifest")
              IMAGE="${manifest%:*}"
              MATRIX_ITEMS=$(echo "$MATRIX_ITEMS" | jq -c \
                --arg image "$IMAGE" --arg digest "$DIGEST" \
                '. += [{"image": $image, "digest": $digest}]')
            done < ghcr-manifests.txt
          fi
          COUNT=$(echo "$MATRIX_ITEMS" | jq 'length')
          if [ "$COUNT" -gt 0 ]; then
            echo "has_manifests=true" >> "$GITHUB_OUTPUT"
            echo "attestation_matrix={\"include\":$MATRIX_ITEMS}" >> "$GITHUB_OUTPUT"
          else
            echo "has_manifests=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Generate manifest report
        run: |
          mkdir -p manifest-results
          # Record Copa's computed target tag for each image that was successfully manifested
          jq -r '[.[] | {image, target}] | unique_by(.image) | .[] | @base64' all-patches.json | \
          while IFS= read -r row; do
            entry=$(echo "$row" | base64 -d)
            IMAGE=$(echo "$entry" | jq -r '.image')
            COPA_TARGET=$(echo "$entry" | jq -r '.target')
            if [ "${{ github.event_name }}" != "pull_request" ]; then
              MANIFEST="${COPA_TARGET}"
            else
              STAGING_TAG="${COPA_TARGET##*/}"
              MANIFEST="${STAGING_REGISTRY}:${STAGING_TAG//:/-}"
            fi
            SAFE_IMAGE_FILE=$(echo "$IMAGE" | tr '/: ' '___')
            echo "{\"image\": \"$IMAGE\", \"manifest\": \"$MANIFEST\"}" \
              > "manifest-results/${SAFE_IMAGE_FILE}.json"
          done

      - name: Upload manifest results
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: manifest-results
          path: manifest-results/
          retention-days: 7

  # ── Job 4: Attest patched images with SBOM ────────────────────────
  attest:
    name: "Attest ${{ matrix.image }}"
    needs: combine
    if: needs.combine.outputs.has_manifests == 'true'
    runs-on: ubuntu-24.04
    strategy:
      matrix: ${{ fromJson(needs.combine.outputs.attestation_matrix) }}
      fail-fast: false
    permissions:
      id-token: write
      attestations: write
      packages: write
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@a90bcbc6539c36a85cdfeb73f7e2f433735f215b # v2.15.0
        with:
          egress-policy: audit

      - name: Login to GHCR
        uses: step-security/docker-login-action@c3e677aae8393bc9c81cfdf9709648720ea4bd4d # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install syft
        uses: anchore/sbom-action/download-syft@f325610c9f50a54015d37c8d16cb3b0e2c8f4de0 # v0.18.0

      - name: Generate SBOM
        run: syft "${{ matrix.image }}@${{ matrix.digest }}" -o cyclonedx-json=sbom.json

      - name: Attest SBOM
        uses: actions/attest-sbom@bd218ad0dbcb3e146bd073d1d9c6d78e08aa8a0b # v2.4.0
        with:
          subject-name: ${{ matrix.image }}
          subject-digest: ${{ matrix.digest }}
          sbom-path: sbom.json
          push-to-registry: true

  # ── Job 5: Post-patch scan ─────────────────────────────────────────
  post-scan:
    name: Post-Patch Scan
    needs: [scan, combine]
    if: always() && needs.combine.result == 'success'
    runs-on: ubuntu-24.04
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@a90bcbc6539c36a85cdfeb73f7e2f433735f215b # v2.15.0
        with:
          egress-policy: audit

      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff # v5.6.0
        with:
          go-version-file: go.mod

      - name: Login to GHCR
        uses: step-security/docker-login-action@c3e677aae8393bc9c81cfdf9709648720ea4bd4d # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup binaries
        uses: ./.github/actions/setup-binaries
        with:
          github-token: ${{ github.token }}

      - name: Setup Trivy
        uses: step-security/setup-trivy@c90a9e4ee674152fc961ef98d44fc670a5dcceb7 # v0.2.5
        with:
          version: v0.68.2
          cache: true

      - name: Cache Trivy database
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/.cache/trivy
          key: trivy-db-${{ github.run_id }}
          restore-keys: |
            trivy-db-

      - name: Download scan results (for results.json)
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: scan-results
          path: .

      - name: Scan patched images
        run: |
          # Scan only the patched manifest images to capture remaining vulnerabilities
          ./verity scan \
            --config copa-config.yaml \
            --target-registry "$TARGET_REGISTRY" \
            --patched-only \
            --parallel 10 \
            --output post-reports/

      - name: Upload post-patch scan results
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: post-scan-results
          path: post-reports/
          retention-days: 30

  # ── Job 6: Generate catalog ────────────────────────────────────────
  assemble:
    name: Generate Catalog
    needs: [scan, patch, combine, post-scan]
    if: always() && needs.scan.outputs.has_catalog_images == 'true' && needs.patch.result != 'cancelled'
    runs-on: ubuntu-24.04
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@a90bcbc6539c36a85cdfeb73f7e2f433735f215b # v2.15.0
        with:
          egress-policy: audit

      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: '20.x'
          cache: npm
          cache-dependency-path: site/package-lock.json

      - name: Setup binaries
        uses: ./.github/actions/setup-binaries
        with:
          github-token: ${{ github.token }}

      - name: Download all patch results
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          pattern: patch-result-*
          path: patch-results/
          merge-multiple: true

      - name: Download scan results
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: scan-results
          path: .

      - name: Download post-patch scan results
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        continue-on-error: true
        with:
          name: post-scan-results
          path: post-reports/

      - name: Generate catalog
        run: .github/scripts/generate-catalog.sh results.json reports/ post-reports/ "$TARGET_REGISTRY" site/src/data/catalog.json

      - name: Build site
        working-directory: site
        run: npm ci && npm run build

      - name: Upload PR test artifacts
        if: github.event_name == 'pull_request'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: pr-test-results
          path: |
            .verity/images.json
            site/src/data/catalog.json
          retention-days: 7

      - name: Validate PR testing results
        if: github.event_name == 'pull_request'
        run: .github/scripts/pr-summary.sh "$TARGET_REGISTRY" .verity/images.json site/src/data/catalog.json

      - name: Upload Pages artifact
        if: github.event_name != 'pull_request'
        uses: actions/upload-pages-artifact@7b1f4a764d45c48632c6b24a0339c27f5614fb0b # v4.0.0
        with:
          path: site/dist

  # ── Job 7: Deploy catalog site to GitHub Pages ─────────────────────
  deploy-site:
    name: Deploy Site
    needs: assemble
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-24.04
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    permissions:
      pages: write
      id-token: write
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@a90bcbc6539c36a85cdfeb73f7e2f433735f215b # v2.15.0
        with:
          egress-policy: audit

      - uses: actions/deploy-pages@d6db90164ac5ed86f2b6aed7e0febac5b3c0c03e # v4.0.5
        id: deployment
